/**
 * Progress Reports API Routes
 * 
 * Endpoints for fetching and displaying AI-generated progress tracking reports
 */

import express from 'express';
import { authenticateToken, authorizeRoles } from '../middleware/auth.middleware.js';
import progressTrackingScheduler from '../services/progress-tracking-scheduler.service.js';
import pool from '../config/database.js';

const router = express.Router();

/**
 * Get the latest progress report for the authenticated user's department
 */
router.get('/latest', authenticateToken, authorizeRoles(['department_head', 'department_officer']), async (req, res) => {
  try {
    const departmentId = req.user.department_id;

    if (!departmentId) {
      return res.status(400).json({
        success: false,
        message: 'User is not associated with any department'
      });
    }

    // Get department name for display
    const deptResult = await pool.query(
      'SELECT name FROM departments WHERE id = $1',
      [departmentId]
    );

    if (deptResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Department not found'
      });
    }

    const departmentName = deptResult.rows[0].name;

    // Fetch latest report from Azure Blob Storage using department ID
    const report = await progressTrackingScheduler.getLatestDepartmentReport(departmentId);

    if (!report) {
      return res.json({
        success: true,
        data: null,
        message: 'No reports available yet. Reports are generated every hour.'
      });
    }

    // Parse markdown content
    const parsedReport = parseMarkdownReport(report.content);

    res.json({
      success: true,
      data: {
        departmentId,
        departmentName,
        fileName: report.fileName,
        lastModified: report.lastModified,
        size: report.size,
        content: report.content,
        parsed: parsedReport
      }
    });

  } catch (error) {
    console.error('Error fetching progress report:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch progress report',
      error: error.message
    });
  }
});

/**
 * Get scheduler status (admin only)
 */
router.get('/scheduler/status', authenticateToken, authorizeRoles(['admin']), async (req, res) => {
  try {
    const status = progressTrackingScheduler.getStatus();
    
    res.json({
      success: true,
      data: status
    });

  } catch (error) {
    console.error('Error fetching scheduler status:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch scheduler status',
      error: error.message
    });
  }
});

/**
 * Trigger manual analysis (admin only)
 */
router.post('/scheduler/run', authenticateToken, authorizeRoles(['admin']), async (req, res) => {
  try {
    // Run analysis in background
    progressTrackingScheduler.runAnalysis().catch(error => {
      console.error('Background analysis error:', error);
    });

    res.json({
      success: true,
      message: 'Progress tracking analysis started in background'
    });

  } catch (error) {
    console.error('Error triggering analysis:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to trigger analysis',
      error: error.message
    });
  }
});

/**
 * Parse markdown report into structured data
 */
function parseMarkdownReport(markdown) {
  const sections = [];
  const lines = markdown.split('\n');
  
  let currentSection = null;
  let currentContent = [];

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const trimmedLine = line.trim();
    
    // Skip horizontal rules (---)
    if (trimmedLine === '---' || trimmedLine.startsWith('---')) {
      continue;
    }
    
    // Skip footer text
    if (trimmedLine.includes('This report was generated by') || 
        trimmedLine.includes('Progress Tracking Agent') ||
        trimmedLine.includes('powered by')) {
      continue;
    }
    
    // Skip empty lines at the start of content
    if (!currentSection && !trimmedLine) continue;
    
    // Check for headers
    if (trimmedLine.startsWith('# ')) {
      // Save previous section
      if (currentSection) {
        currentSection.content = currentContent.join('\n').trim();
        if (currentSection.content) {
          sections.push(currentSection);
        }
      }
      currentSection = {
        type: 'title',
        level: 1,
        text: trimmedLine.substring(2).trim(),
        content: ''
      };
      currentContent = [];
    } else if (trimmedLine.startsWith('## ')) {
      // Save previous section
      if (currentSection) {
        currentSection.content = currentContent.join('\n').trim();
        if (currentSection.content) {
          sections.push(currentSection);
        }
      }
      currentSection = {
        type: 'section',
        level: 2,
        text: trimmedLine.substring(3).trim(),
        content: ''
      };
      currentContent = [];
    } else if (trimmedLine.startsWith('### ')) {
      // Save previous section
      if (currentSection) {
        currentSection.content = currentContent.join('\n').trim();
        if (currentSection.content) {
          sections.push(currentSection);
        }
      }
      currentSection = {
        type: 'subsection',
        level: 3,
        text: trimmedLine.substring(4).trim(),
        content: ''
      };
      currentContent = [];
    } else if (trimmedLine.startsWith('#### ')) {
      // Save previous section
      if (currentSection) {
        currentSection.content = currentContent.join('\n').trim();
        if (currentSection.content) {
          sections.push(currentSection);
        }
      }
      currentSection = {
        type: 'subsubsection',
        level: 4,
        text: trimmedLine.substring(5).trim(),
        content: ''
      };
      currentContent = [];
    } else {
      // Content line - only add if not empty or if we have content already
      if (trimmedLine || currentContent.length > 0) {
        currentContent.push(line);
      }
    }
  }

  // Add last section
  if (currentSection) {
    currentSection.content = currentContent.join('\n').trim();
    if (currentSection.content) {
      sections.push(currentSection);
    }
  }

  // Filter out sections that are just metadata or reference sections
  const filteredSections = sections.filter(section => {
    const text = section.text?.toLowerCase() || '';
    const content = section.content?.toLowerCase() || '';
    
    // Skip "Data Summary (Reference)" section
    if (text.includes('data summary') && text.includes('reference')) {
      return false;
    }
    
    // Skip sections with footer text
    if (content.includes('this report was generated by') || 
        content.includes('progress tracking agent')) {
      return false;
    }
    
    return true;
  });

  // Extract metadata from first section
  const metadata = {};
  const metadataSection = filteredSections.find(s => s.type === 'title');
  if (metadataSection && metadataSection.content) {
    const metaLines = metadataSection.content.split('\n');
    for (const line of metaLines) {
      if (line.includes('**Generated:**')) {
        metadata.generatedAt = line.split('**Generated:**')[1].trim();
      } else if (line.includes('**Department ID:**')) {
        metadata.departmentId = line.split('**Department ID:**')[1].trim();
      } else if (line.includes('**Report Type:**')) {
        metadata.reportType = line.split('**Report Type:**')[1].trim();
      }
    }
  }

  // Extract key metrics from Performance Metrics or Data Summary section
  const metrics = {};
  const metricsSection = filteredSections.find(s => 
    s.text && (
      s.text.includes('Performance Metrics') || 
      s.text.includes('Overall Statistics') ||
      s.text.includes('Data Summary')
    )
  );
  
  if (metricsSection && metricsSection.content) {
    const metricLines = metricsSection.content.split('\n');
    for (const line of metricLines) {
      const trimmed = line.trim();
      if (trimmed.includes('**Total Grievances:**') || trimmed.includes('Total Grievances:')) {
        const match = trimmed.match(/Total Grievances:\s*(\d+)/);
        if (match) metrics.totalGrievances = parseInt(match[1]) || 0;
      } else if (trimmed.includes('**Resolution Rate:**') || trimmed.includes('Resolution Rate:')) {
        const match = trimmed.match(/Resolution Rate:\s*([\d.]+)%/);
        if (match) metrics.resolutionRate = parseFloat(match[1]) || 0;
      } else if (trimmed.includes('**Performance Score:**') || trimmed.includes('Performance Score:')) {
        const match = trimmed.match(/Performance Score:\s*([\d.]+)/);
        if (match) metrics.performanceScore = parseFloat(match[1]) || 0;
      } else if (trimmed.includes('**Officer Utilization:**') || trimmed.includes('Officer Utilization:')) {
        const match = trimmed.match(/Officer Utilization:\s*([\d.]+)%/);
        if (match) metrics.officerUtilization = parseFloat(match[1]) || 0;
      } else if (trimmed.includes('**Budget Utilization:**') || trimmed.includes('Budget Utilization:')) {
        const match = trimmed.match(/Budget Utilization:\s*([\d.]+)%/);
        if (match) metrics.budgetUtilization = parseFloat(match[1]) || 0;
      }
    }
  }

  // Process content to format paragraphs properly
  const processedSections = filteredSections.map(section => {
    if (!section.content) return section;
    
    // Split content into paragraphs (separated by blank lines)
    const paragraphs = section.content
      .split(/\n\s*\n/)
      .map(p => p.trim())
      .filter(p => p.length > 0)
      .filter(p => {
        // Filter out footer text from paragraphs
        const lower = p.toLowerCase();
        return !lower.includes('this report was generated by') && 
               !lower.includes('progress tracking agent') &&
               !lower.includes('powered by');
      });
    
    return {
      ...section,
      paragraphs: paragraphs,
      content: section.content
    };
  });

  return {
    metadata,
    metrics,
    sections: processedSections.filter(s => s.content && s.content.length > 0)
  };
}

export default router;
